# PicoRuby Development Guide for <%= project_name %>

**Auto-generated by `ptrk new` on <%= created_at %>**

This file contains development conventions and setup instructions for PicoRuby application developers using the `picotorokko` build system.

## Project Setup

**Project Name**: <%= project_name %>
**Author**: <%= author %>
**Created**: <%= created_at %>

## Development Workflow

### 1. Environment Management

All PicoRuby versions are managed through `.picoruby-env.yml` and controlled via `ptrk env` commands:

```bash
# Create a new environment
ptrk env set main --commit abc1234

# View current environment
ptrk env show main

# List all environments
ptrk env list

# Switch environments
ptrk env set development
```

### 2. Building and Testing

Always work in the `build/` directory for compilation:

```bash
# Setup build environment (creates build/current/ symlink)
ptrk build setup

# Build (in R2P2-ESP32 directory)
cd build/current/R2P2-ESP32
rake build
cd ../../..

# Or use delegation (if available in future ptrk versions)
ptrk device build
```

### 3. Application Code Organization

Your application code goes in `storage/home/`:

```
storage/home/
├── main.rb        # Entry point (auto-included by R2P2-ESP32)
├── lib/           # Application libraries (optional)
│   └── my_module.rb
└── ...
```

### 4. Making Changes and Patching

To customize R2P2-ESP32 or dependencies:

1. **Edit in `build/current/R2P2-ESP32/`**
2. **Export as patches**:
   ```bash
   ptrk patch export
   ```
3. **Commit to git**:
   ```bash
   git add patch/ storage/home/
   git commit -m "Update application and patches"
   ```
4. **Apply to other environments**:
   ```bash
   ptrk env set development
   ptrk build setup  # patches auto-applied
   ```

## Directory Structure

```
<project-root>/
├── storage/home/           # Your application code (git-managed)
├── patch/                  # Customizations (git-managed)
│   ├── R2P2-ESP32/
│   ├── picoruby-esp32/
│   └── picoruby/
│
├── .cache/                 # Repository snapshots (git-ignored)
├── build/                  # Build working directory (git-ignored)
├── .ptrk_env/              # Environment metadata (git-ignored)
│
├── .picoruby-env.yml       # Environment definitions
├── .gitignore
├── Gemfile
├── README.md
└── CLAUDE.md               # This file
```

## Useful Commands

### Environment Inspection

```bash
ptrk env show main          # Show environment configuration
ptrk env list               # List all environments
```

### Build Management

```bash
ptrk build setup main       # Setup build environment
ptrk build list             # List available builds
ptrk build clean            # Clean current build
```

### Cache Management

```bash
ptrk cache list             # List cached versions
ptrk cache fetch latest     # Fetch latest versions
ptrk cache prune            # Remove unused caches
```

### Patch Management

```bash
ptrk patch export           # Export changes to patches/
ptrk patch apply            # Apply patches to build/
ptrk patch diff             # Show changes vs patches
```

## Tips and Best Practices

### Cache Efficiency

- **Reuse versions**: Multiple environments can share cache entries
- **Clean up**: Run `ptrk cache prune` to free disk space
- **Immutable cache**: Caches are never modified; always create new ones for changes

### Patch Management

- **Export frequently**: Use `ptrk patch export` after changes to ensure patches are saved
- **Test patches**: Switch environments to verify patches apply correctly to different versions
- **Keep patches simple**: Smaller patches are easier to understand and maintain

### Build Performance

- **Reuse build directories**: Use `ptrk env set` to switch instead of `ptrk build clean` + setup
- **Monitor disk**: Build directories can be large; monitor `.cache/` and `build/` sizes

## Troubleshooting

### Build Environment Missing

```bash
# List available builds
ptrk build list

# If missing, setup the environment
ptrk build setup main
```

### Patches Not Applied

```bash
# Check patch differences
ptrk patch diff

# Re-setup build (patches auto-applied)
ptrk build clean
ptrk build setup
```

### Cache Issues

```bash
# Check cache
ptrk cache list

# Clean and re-fetch if needed
ptrk cache clean R2P2-ESP32
ptrk cache fetch latest
```

## Further Documentation

- **`README.md`** — Project overview and quick start
- **`SPEC.md`** — Complete ptrk command specification (in picotorokko gem)
- **`https://github.com/picoruby/picotorokko`** — picotorokko gem repository and documentation
- **`https://github.com/picoruby/R2P2-ESP32`** — R2P2-ESP32 repository
- **`https://github.com/picoruby/picoruby`** — PicoRuby language repository

## Environment Variables

When running commands in `build/current/R2P2-ESP32/`, the following environment is important:

- **ESP-IDF setup** — Automatically handled by R2P2-ESP32's Rakefile
- **Git submodules** — Already cloned and configured by ptrk
- **Build cache** — Reused within same build environment (build/ directory)

No manual environment setup is required when using `ptrk` commands.

## Development Tips

1. **Small commits**: Keep commits focused on single changes (application OR patches, not both)
2. **Test regularly**: After `ptrk env set`, verify with `ptrk env show` before building
3. **Document patches**: Add notes in `patch/README.md` explaining why custom patches exist
4. **Version management**: Use descriptive environment names like `stable`, `testing`, `development`

---

## PicoRuby Application Development Guide

### Understanding mrbgems

PicoRuby extends functionality through **mrbgems** (mruby gems):

```ruby
# Mrbgemfile - Declare your dependencies
conf.gem github: 'user/mrbgem-name', branch: 'main'
conf.gem github: 'picoruby/picoruby-ws2812'  # RGB LEDs
conf.gem github: 'picoruby/picoruby-gpio'    # GPIO control
```

**Key points**:
- ✅ GitHub repos are auto-fetched during build
- ✅ Branches and commits can be specified
- ✅ Local mrbgems: use relative paths like `../path/to/gem`
- ✅ Always run `ptrk env set --latest` to ensure latest versions

### Peripheral APIs: I2C, GPIO, RMT

#### I2C (Inter-Integrated Circuit)

```ruby
require 'i2c'

i2c = I2C.new(
  unit: :ESP32_I2C0,
  frequency: 100_000,   # Hz
  sda_pin: 21,
  scl_pin: 22
)

sensor = MyI2CDevice.new(i2c)
data = sensor.read
```

**Common devices**:
- MPU6886 (accelerometer/gyroscope)
- BMP280 (pressure/temperature)
- SSD1306 (OLED display)

#### GPIO (General Purpose I/O)

```ruby
require 'gpio'

led = GPIO.new(pin_number, GPIO::OUT)
button = GPIO.new(pin_number, GPIO::IN)

led.write(1)           # Set HIGH
value = button.read()  # Read 0 or 1
```

**Pin modes**:
- `GPIO::OUT` — Output (control external devices)
- `GPIO::IN` — Input (read sensors/buttons)
- `GPIO::PULLUP` — Input with internal pull-up resistor

#### RMT (Remote Control Transmitter)

Used for addressable RGB LEDs (WS2812):

```ruby
require 'ws2812'

rmt = RMTDriver.new(pin_number)
led = WS2812.new(rmt)

# Show 25 pixels (5x5 grid on ATOM Matrix)
colors = Array.new(25, 0xFF0000)  # Red
led.show_hex(*colors)
```

**Color format**:
- Hexadecimal: `0xRRGGBB`
- Examples: `0xFF0000` (red), `0x00FF00` (green), `0x0000FF` (blue)

### Memory Optimization for PicoRuby

PicoRuby runs on microcontrollers with **limited RAM** (typically 4-16 MB). Follow these practices:

#### 1. Avoid Large Arrays

```ruby
# ❌ Bad: Creates large intermediate array
data = Array.new(1000) { rand(1000) }

# ✅ Good: Process incrementally
1000.times do |i|
  process_value(rand(1000))
end
```

#### 2. Use String Literals Efficiently

```ruby
# ❌ Bad: Creates new string each loop iteration
100.times do
  puts "Hello"
end

# ✅ Good: Reuse string
msg = "Hello"
100.times { puts msg }
```

#### 3. Minimize Object Allocations

```ruby
# ❌ Bad: Creates object in loop
loop do
  point = Point.new(x, y)
  process(point)
end

# ✅ Good: Reuse object
point = Point.new(0, 0)
loop do
  point.x, point.y = get_coords()
  process(point)
end
```

#### 4. Use Frozen Strings (Ruby 3.3+)

```ruby
# Ruby 3.3+ automatically freezes string literals
# This saves memory by sharing string objects
name = "Device"  # Frozen automatically
```

### RuboCop for Code Quality

This project includes RuboCop for style consistency:

```bash
# Check code style
bundle exec rubocop

# Auto-fix style issues
bundle exec rubocop -A
```

**Configured for PicoRuby**:
- Stricter method length (max 20 lines) for memory efficiency
- Smaller class size (max 150 lines) for maintainability
- Double-quoted strings (PicoRuby convention)
- Japanese comments allowed for device-specific documentation

### Testing with Picotest

PicoRuby applications can use **Picotest** for unit testing:

```ruby
# test/app_test.rb
class MyAppTest < Picotest::Test
  def test_sensor_reading
    sensor = MockSensor.new
    value = sensor.read
    assert_equal(42, value)
  end

  def test_gpio_output
    mock_any_instance_of(GPIO) do |gpio|
      expect(gpio).write(1).returns(nil)
    end

    led = GPIO.new(5, GPIO::OUT)
    led.write(1)
  end
end
```

Run tests with:
```bash
ptrk device build --test
ptrk device monitor --test
```

---

**Generated by picotorokko v{{PICOTOROKKO_VERSION}} — https://github.com/picoruby/picotorokko**
